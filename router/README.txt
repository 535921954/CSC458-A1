The code that handles the ARP cache is split into three sections: sr_arpcache_sweepreqs, handle_arpreq, and send_arp_packet.  This is done to separate the tasks that need to be completed for the arp caache to work.  sr_arpcache_sweepreqs selects the request that needs to the processed.  A while loop is used instead of a for loop in case one of the requests is deleted during the processing and it misses a request.  handle_arpreq manages the ARP requests, either sending them out, or destroying them if they have already been sent 5 times.  send_arp_packet handles the ARP request packet creation.  It fills in the fields in the sr_ethernet_hdr and sr_arp_hdr structs before converting them into uint8_t arrays and sent out.

In sr_router.c, sr_handlepacket redirects the packets to different functions depending on what kind of packets they are.  ARP packets are sent to handle_arppacket function.  If statements are used to differentiate between replies and requests.  For replies, since most of the packet information is the same, with some addresses flipped around, it copies the packet and updates the values that needs to be changed and sends the reply.  It also caches the source hardware and protocol address so it doesn't need to send an ARP when sending packets to them.  If the ARP packet is a reply, then it goes through the procedure of caching the addresses and sending the packets that are queued for the reply.  This involves updating the header information for the IP packets.

If the packets arriving are IP packets, handle_ippacket takes care of them.  The first section of this function checks for any errors in the packet, otherwise they are dropped.  Afterwards, it checks if the packet is for itself or it goes somewhere else.  If it goes somewhere else, then it needs to perform LPM, which is does by keeping track of the longest prefix as it goes through each entry in the routing table using a character array.  If it finds a match, it either queues the packet to wait for an ARP reply, or sends the packet after updating the packet headers.

There are also two helper functions that are used to convert uint8_t arrays to uint16_t or uint32_t since casting the array changes their values.  Instead of having to create an uint16_t to uint8_t array conversion function for the checksum, the values are bit shifted and assigned to the appropriate indices in the packet.